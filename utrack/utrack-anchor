#!/usr/bin/python3
#
# Station daemon uTrack emulation
#

import sys
import time
import socket
import select
import ctypes
import struct
import array
import random
import argparse
import ipaddress
import netifaces
import requests
import json

import RPi.GPIO as GPIO

from pprint import pprint
from ctypes import *


class Config():

    utrack_server            = '127.0.0.1:8000'

    utrack_device_id         = 'TailStation'
    utrack_station_group     = 'TailGroup'
    utrack_station_location  = 'TailLoc'
    
    utrack_event_url         = '/timesheet/beacon/event'
    
    utrack_in_distance       = 0.5  # [m]
    utrack_out_distance      = 1.0  # [m]
    utrack_tag_expire        = 240   # [s]
    
    dw1000_channel  = 7
    dw1000_pcode    = 20
    dw1000_rate     = 850
    dw1000_txpsr    = 1024
    dw1000_power    = 0x91919191
    dw1000_antd     = 0x4020
    dw1000_sysfs    = '/sys/devices/platform/soc/3f204000.spi/spi_master/spi0/spi0.0/dw1000/'

    if_name         = 'lowpan0'
    if_addr         = None
    if_index        = 0

    mcast_addr      = 'ff12::52'
    mcast_port      = 0xf0b0
    mcast_bind      = None
    
    twr_port        = 0xf0b1
    twr_bind        = None
    twr_expr        = 1.0

    gpio_pin        = 17

cfg = Config()

twr_status = {}
tag_status = {}


C_AIR = 299705000

DW1000_CLOCK_GHZ = 63.8976

IPV6_ERR_QUEUE_OFFSET = 0
UDP6_ERR_QUEUE_OFFSET = 31


for name,value in (
        ('SO_TIMESTAMPING', 37),
        ('SO_SELECT_ERR_QUEUE', 45),
	('SOF_TIMESTAMPING_TX_HARDWARE',  (1<<0)),
  	('SOF_TIMESTAMPING_TX_SOFTWARE',  (1<<1)),
        ('SOF_TIMESTAMPING_RX_HARDWARE',  (1<<2)),
        ('SOF_TIMESTAMPING_RX_SOFTWARE',  (1<<3)),
        ('SOF_TIMESTAMPING_SOFTWARE',     (1<<4)),
        ('SOF_TIMESTAMPING_SYS_HARDWARE', (1<<5)),
        ('SOF_TIMESTAMPING_RAW_HARDWARE', (1<<6)),
        ('SOF_TIMESTAMPING_OPT_ID',       (1<<7)),
        ('SOF_TIMESTAMPING_TX_SCHED',     (1<<8)),
        ('SOF_TIMESTAMPING_TX_ACK',       (1<<9)),
        ('SOF_TIMESTAMPING_OPT_CMSG',     (1<<10)),
        ('SOF_TIMESTAMPING_OPT_TSONLY',   (1<<11)),
        ('SOF_TIMESTAMPING_OPT_STATS',    (1<<12)),
        ('SOF_TIMESTAMPING_OPT_PKTINFO',  (1<<13)),
        ('SOF_TIMESTAMPING_OPT_TX_SWHW',  (1<<14))):
    if not hasattr(socket, name):
        setattr(socket, name, value)

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
GPIO.setup(cfg.gpio_pin,GPIO.OUT)


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)
    pass

def dprint(*args, **kwargs):
    #print(*args, file=sys.stderr, **kwargs)
    pass


class Timespec(Structure):

    _fields_ = [("tv_sec", c_long),
                ("tv_nsec", c_long)]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)

    def __int__(self):
        return ((self.tv_sec * 1000000000 + self.tv_nsec) << 32)

    def __str__(self):
        return '%#x' % int(self)

    def __bool__(self):
        return bool(self.tv_sec or self.tv_nsec)


class Timehires(Structure):

    _fields_ = [
        ("tv_nsec", c_uint64),
        ("tv_frac", c_uint32),
        ("__res", c_uint32) ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)

    def __int__(self):
        return ((self.tv_nsec << 32) | self.tv_frac)

    def __str__(self):
        return '%#x' % int(self)

    def __bool__(self):
        return bool(self.tv_nsec or self.tv_frac)


class TimestampInfo(Structure):

    _fields_ = [
        ("rawts", c_uint64),
        ("lqi", c_uint16),
        ("snr", c_uint16),
        ("fpr", c_uint16),
        ("noise", c_uint16),
        ("rxpacc", c_uint16),
        ("fp_index", c_uint16),
        ("fp_ampl1", c_uint16),
        ("fp_ampl2", c_uint16),
        ("fp_ampl3", c_uint16),
        ("cir_pwr", c_uint32),
        ("fp_pwr", c_uint32),
        ("ttcko", c_uint32),
        ("ttcki", c_uint32),
    ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)


class Timestamp(Structure):

    _fields_ = [
        ("sw", Timespec),
        ("legacy", Timespec),
        ("hw", Timespec),
        ("hires", Timehires),
        ("tsinfo", TimestampInfo),
    ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)


def uTrackReport(eui,cmd,rssi=42,txpwr=42):
    print('*{:3s} <{}>'.format(cmd.upper(),eui))
    try:
        requests.post(
            'http://' + cfg.utrack_server + cfg.utrack_event_url,
            json = {
                'event_type':       cmd,
                'event_time':       time.time(),
                'device_id':        cfg.utrack_device_id,
                'station_group':    cfg.utrack_station_group,
                'station_location': cfg.utrack_station_location,
                'metadata': {
                    'rssi':       rssi,
                    'tx_power':   txpwr,
                    'namespace':  'tail',
                    'instance':   eui,
                },
            }
        )
    except Exception as err:
        eprint('uTrack request failed: {}'.format(err))


def uTrackInEvent(eui):
    uTrackReport(eui,'in')
    GPIO.output(cfg.gpio_pin, GPIO.LOW)
    tag_status[eui]['status'] = 'IN'

def uTrackOutEvent(eui):
    uTrackReport(eui,'out')
    GPIO.output(cfg.gpio_pin, GPIO.HIGH)
    tag_status[eui]['status'] = 'OUT'


def UpdateTag(eui,lof):
    print('     <{}> {:.3f}m'.format(eui,lof))
    if eui not in tag_status:
        tag_status[eui] = { 'status':'OUT', 'expire':0.0 }
    if tag_status[eui]['status'] == 'IN':
        if lof > cfg.utrack_out_distance:
            uTrackOutEvent(eui)
    else:
        if lof < cfg.utrack_in_distance:
            uTrackInEvent(eui)
    tag_status[eui]['expire'] = time.time() + cfg.utrack_tag_expire


def PurgeTags():
    now = time.time()
    for eui in list(tag_status.keys()):
        if tag_status[eui]['expire'] < now:
            if tag_status[eui]['status'] == 'IN':
                uTrackOutEvent(eui)
            del tag_status[eui]

def PurgeTWRs():
    now = time.time()
    for tag in list(twr_status.keys()):
        if twr_status[tag]['expire'] < now:
            dprint('Purging old TWR for <{}>'.format(tag))
            del twr_status[tag]


def TWR(times):
    dprint('TWR with {}'.format(times))
    (T1,T2,T3,T4,T5,T6) = times[0:6]
    T41 = T4 - T1
    T32 = T3 - T2
    T54 = T5 - T4
    T63 = T6 - T3
    T51 = T5 - T1
    T62 = T6 - T2
    #eprint('T41: {}'.format(T41))
    #eprint('T32: {}'.format(T32))
    #eprint('T54: {}'.format(T54))
    #eprint('T63: {}'.format(T63))
    #eprint('T51: {}'.format(T51))
    #eprint('T62: {}'.format(T62))
    Tof = (T41*T63 - T32*T54) / (T51+T62)
    Dof = Tof / DW1000_CLOCK_GHZ
    Lof = Dof * C_AIR * 1E-9
    #eprint('Tof: {:.3f}'.format(Tof))
    #eprint('Dof: {:.3f}ns'.format(Dof))
    #eprint('Lof: {:.3f}m'.format(Lof))
    if Lof<-1.0 or Lof>30.0:
        raise ValueError('Distance out-of-bounds')
    return Lof


def SetDWAttr(attr, data):
    fd = open(cfg.dw1000_sysfs + attr, 'w')
    fd.write(str(data))
    fd.close()

def GetDWAttr(attr):
    fd = open(cfg.dw1000_sysfs + attr, 'r')
    val = fd.read().rstrip()
    fd.close()
    return val


def GetTagEUI(addr):
    ip = ipaddress.ip_address(addr)
    if ip.is_link_local:
        tag = bytearray(ip.packed[8:])
        tag[0] ^= 0x02
        return tag
    else:
        return None

def GetRawEUI(data):
    eui = bytearray(data)
    eui[0],eui[7] = eui[7],eui[0]
    eui[1],eui[6] = eui[6],eui[1]
    eui[2],eui[5] = eui[5],eui[2]
    eui[3],eui[4] = eui[4],eui[3]
    return bytes(eui)


def GetAnclTs(ancl):
    tss = Timestamp()
    for cmsg_level, cmsg_type, cmsg_data in ancl:
        if (cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SO_TIMESTAMPING):
            raw = cmsg_data.ljust(sizeof(Timestamp), b'\0')
            tss = Timestamp.from_buffer_copy(raw)
    return tss


def GetXtalPPM(tsi):
    TTCKI = tsi.ttcki
    TTCKO = tsi.ttcko
    if TTCKO & 0x040000:
        TTCKO -= 0x080000
        if TTCKI != 0:
            return TTCKO / TTCKI
    return 0.0


def RecvMcast(msock,tsock):
    (data,ancl,_,rem) = msock.recvmsg(4096, 1024, 0)
    (flags,) = struct.unpack('B', data[0:1])
    tag = rem[0].partition('%')[0]
    eui = GetTagEUI(tag)
    tss = GetAnclTs(ancl)
    twr_status[tag] = {
        'eui'     : eui,
        'addr'    : tag,
        'start'   : time.time(),
        'expire'  : time.time() + cfg.twr_expr,
        'times'   : [None,None,None,None,None,None],
    }
    twr_status[tag]['times'][0] = 0
    twr_status[tag]['times'][1] = tss.tsinfo.rawts
    msg = struct.pack('<B', 0x08)
    dst = (rem[0],rem[1],rem[2],rem[3])
    tsock.sendto(msg,dst)
    dprint('RecvMcast: {} {} 0x{:02x} {}'.format(tag,eui.hex(),flags,tss.tsinfo.rawts))


def RecvTag(tsock):
    (data,ancl,flags,rem) = tsock.recvmsg(4096, 1024, 0)
    (flags,T1a,T1b,T1c,T1d,T1e,T2a,T2b,T2c,T2d,T2e) = struct.unpack('<B5B5B', data[0:12])
    T1 = (T1e<<32) | (T1d<<24) | (T1c<<16) | (T1b<<8) | (T1a)
    T2 = (T2e<<32) | (T2d<<24) | (T2c<<16) | (T2b<<8) | (T2a)
    tag = rem[0].partition('%')[0]
    tss = GetAnclTs(ancl)
    dprint('RecvTag(<{}>,{},{},{})'.format(tag,flags,T1,T2))
    dprint('RecvTag({}): {:.2f}ppm'.format(tag,GetXtalPPM(tss.tsinfo)*1E6))
    if tag in twr_status:
        EUI = twr_status[tag]['eui'].hex()
        twr_status[tag]['times'][3] = T1
        twr_status[tag]['times'][4] = T2
        twr_status[tag]['times'][5] = tss.tsinfo.rawts
        try:
            dis = TWR(twr_status[tag]['times'])
        except Exception as err:
            eprint('TWR failed: {}'.format(err))
        else:
            UpdateTag(EUI,dis)
        del twr_status[tag]


def GetTxTime(tsock):
    (data,ancl,_,_) = tsock.recvmsg(4096, 1024, socket.MSG_ERRQUEUE)
    eui = GetRawEUI(data[5:13])
    for tag in twr_status:
        if twr_status[tag]['eui'] == eui:
            tss = GetAnclTs(ancl)
            twr_status[tag]['times'][2] = tss.tsinfo.rawts
            dprint('GetTxTime({},{},{})'.format(tag,eui.hex(),tss.tsinfo.rawts))
            return


def SocketLoop():
    
    while True:

        msock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        msock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        ireq = struct.pack('I', cfg.if_index)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_IF, ireq)
        
        addr = socket.inet_pton(socket.AF_INET6, cfg.mcast_addr)
        mreq = struct.pack('16sI', addr, cfg.if_index)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_JOIN_GROUP, mreq)
        
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 0)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)
        
        msock.setsockopt(socket.SOL_SOCKET, socket.SO_TIMESTAMPING,
                         socket.SOF_TIMESTAMPING_RX_HARDWARE |
                         socket.SOF_TIMESTAMPING_TX_HARDWARE |
                         socket.SOF_TIMESTAMPING_RAW_HARDWARE)
        
        msock.bind(cfg.mcast_bind)
        
        tsock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_TIMESTAMPING,
                         socket.SOF_TIMESTAMPING_RX_HARDWARE |
                         socket.SOF_TIMESTAMPING_TX_HARDWARE |
                         socket.SOF_TIMESTAMPING_RAW_HARDWARE)
        
        tsock.bind(cfg.twr_bind)

        pobj = select.poll()
        pobj.register(msock, select.POLLIN)
        pobj.register(tsock, select.POLLIN)

        fail = 0
        while fail < 30:
            fail += 1
            PurgeTWRs()
            PurgeTags()
            fds = pobj.poll(100)
            for (fd,flags) in fds:
                fail = 0
                if fd == msock.fileno():
                    if flags & select.POLLIN:
                        RecvMcast(msock,tsock)
                    else:
                        eprint('Unexpected msock activity {}'.format(flags))
                elif fd == tsock.fileno():
                    if flags & select.POLLIN:
                        RecvTag(tsock)
                    elif flags & select.POLLERR:
                        GetTxTime(tsock)
                    else:
                        eprint('Unexpected tsock activity: {}'.format(flags))
                else:
                    eprint('Unexpected socket [{}] activity'.format(fd))
        
        dprint('Socket recovery')

        msock.close()
        tsock.close()



def main():
    
    global cfg
    
    parser = argparse.ArgumentParser(description="uTrack Station daemon")
    
    parser.add_argument('-i', '--interface', type=str, default=cfg.if_name)
    parser.add_argument('-p', '--port', type=int, default=cfg.twr_port)
    parser.add_argument('-P', '--mcast-port', type=int, default=cfg.mcast_port)
    parser.add_argument('-r', '--radius', type=float, default=cfg.utrack_in_distance)
    parser.add_argument('-s', '--server', type=str, default=cfg.utrack_server)
    
    args = parser.parse_args()

    cfg.utrack_server = args.server

    cfg.utrack_in_distance  = args.radius
    cfg.utrack_out_distance = args.radius + 0.5

    cfg.if_name   = args.interface
    cfg.if_addr   = netifaces.ifaddresses(args.interface)
    cfg.if_index  = socket.if_nametoindex(args.interface)
    
    cfg.twr_port    = args.port
    cfg.twr_bind    = ('', cfg.twr_port, 0, cfg.if_index)
    
    cfg.mcast_port  = args.mcast_port
    cfg.mcast_bind  = ('', cfg.mcast_port, 0, cfg.if_index)
    
    SetDWAttr('channel', cfg.dw1000_channel)
    SetDWAttr('pcode', cfg.dw1000_pcode)
    SetDWAttr('rate', cfg.dw1000_rate)
    SetDWAttr('txpsr', cfg.dw1000_txpsr)
    SetDWAttr('smart_power', 0)
    SetDWAttr('tx_power', cfg.dw1000_power)
    SetDWAttr('antd', cfg.dw1000_antd)
        
    SocketLoop()
    

if __name__ == "__main__":
    main()


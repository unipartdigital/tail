#!/usr/bin/python3
#
# uTrack Station connector daemon
#

import sys
import time
import socket
import select
import ctypes
import struct
import array
import argparse
import ipaddress
import netifaces
import json

from ctypes import *


class Config():

    dw1000_channel  = 7
    dw1000_pcode    = 20
    dw1000_prf      = 64
    dw1000_rate     = 850
    dw1000_txpsr    = 1024
    dw1000_power    = 0x91919191
    dw1000_sysfs    = '/sys/devices/platform/soc/3f204000.spi/spi_master/spi0/spi0.0/dw1000/'

    if_name         = 'lowpan0'
    if_addr         = None
    if_index        = 0

    mcast_addr      = 'ff12::52'
    mcast_port      = 0xf0b0
    mcast_bind      = None
    
    twr_port        = 0xf0b1
    twr_bind        = None
    twr_expr        = 1.0

    utrack_port     = 6299
    utrack_bind     = None

cfg = Config()

twr_status = {}
utrack_sockets = []

DEBUG = 0

Cs = 299792458
DW1000_CLOCK_HZ = 63.8976E9


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint(*args, **kwargs):
    if DEBUG > 0:
        print(*args, file=sys.stderr, **kwargs)


class Timespec(Structure):

    _fields_ = [("tv_sec", c_long),
                ("tv_nsec", c_long)]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)

    def __int__(self):
        return ((self.tv_sec * 1000000000 + self.tv_nsec) << 32)

    def __str__(self):
        return '%#x' % int(self)

    def __bool__(self):
        return bool(self.tv_sec or self.tv_nsec)


class Timehires(Structure):

    _fields_ = [
        ("tv_nsec", c_uint64),
        ("tv_frac", c_uint32),
        ("__res", c_uint32) ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)

    def __int__(self):
        return ((self.tv_nsec << 32) | self.tv_frac)

    def __str__(self):
        return '%#x' % int(self)

    def __bool__(self):
        return bool(self.tv_nsec or self.tv_frac)


class TimestampInfo(Structure):

    _fields_ = [
        ("rawts", c_uint64),
        ("lqi", c_uint16),
        ("snr", c_uint16),
        ("fpr", c_uint16),
        ("noise", c_uint16),
        ("rxpacc", c_uint16),
        ("fp_index", c_uint16),
        ("fp_ampl1", c_uint16),
        ("fp_ampl2", c_uint16),
        ("fp_ampl3", c_uint16),
        ("cir_pwr", c_uint32),
        ("fp_pwr", c_uint32),
        ("ttcko", c_uint32),
        ("ttcki", c_uint32),
        ("temp", c_uint16),
        ("volt", c_uint16),
    ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)


class Timestamp(Structure):

    _fields_ = [
        ("sw", Timespec),
        ("legacy", Timespec),
        ("hw", Timespec),
        ("hires", Timehires),
        ("tsinfo", TimestampInfo),
    ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)

    
def uTrackAddClient(socket):
    (csock,caddr) = socket.accept()
    utrack_sockets.append(csock)
    dprint('New uTrack client: {}'.format(csock))
    
def uTrackDelClient(socket):
    dprint('Remove uTrack client {}'.format(socket))
    socket.close()
    utrack_sockets.remove(socket)

    
def uTrackReportTag(eui,dist):
    dprint('Report <{}> {:.3f}m'.format(eui,dist))
    msg = {
        'EUI'  : eui,
        'Dist' : int(dist*1000),
    }
    data = json.dumps(msg).encode() + b'\x1f'
    for s in list(utrack_sockets):
        try:
            s.send(data)
        except:
            uTrackDelClient(s)


def PurgeTWRs(all=False):
    now = time.time()
    for tag in list(twr_status.keys()):
        if twr_status[tag]['expire'] < now or all:
            dprint('TWR expired for <{}>'.format(tag))
            del twr_status[tag]


def TWR(T):
    dprint('TWR with {}'.format(T))
    T41 = T[3] - T[0]
    T32 = T[2] - T[1]
    T54 = T[4] - T[3]
    T63 = T[5] - T[2]
    T51 = T[4] - T[0]
    T62 = T[5] - T[1]
    Tof = (T41*T63 - T32*T54) / (T51+T62)
    Dof = (Tof / DW1000_CLOCK_HZ) * Cs
    if Dof<-1.0 or Dof>50.0:
        raise ValueError('TWR distance out-of-bounds')
    return Dof


def SetDWAttr(attr, data):
    with open(cfg.dw1000_sysfs + attr, 'w') as f:
        f.write(str(data))

def GetDWAttr(attr):
    with open(cfg.dw1000_sysfs + attr, 'r') as f:
        value = f.read()
    return value.rstrip()

def GetTagEUI(addr):
    ip = ipaddress.ip_address(addr)
    if ip.is_link_local:
        tag = bytearray(ip.packed[8:])
        tag[0] ^= 0x02
        return tag
    raise ValueError('EUI not known')

def GetRawEUI(data):
    eui = bytearray(data)
    eui[0],eui[7] = eui[7],eui[0]
    eui[1],eui[6] = eui[6],eui[1]
    eui[2],eui[5] = eui[5],eui[2]
    eui[3],eui[4] = eui[4],eui[3]
    return bytes(eui)

def GetAnclTs(ancl):
    for cmsg_level, cmsg_type, cmsg_data in ancl:
        if (cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SO_TIMESTAMPING):
            raw = cmsg_data.ljust(sizeof(Timestamp), b'\0')
            tss = Timestamp.from_buffer_copy(raw)
            return tss
    raise RuntimeError('Timestamp not available')


def RecvTagMcast(msock,tsock):
    (data,ancl,_,rem) = msock.recvmsg(4096, 1024, 0)
    (flags,) = struct.unpack('B', data[0:1])
    tag = rem[0].partition('%')[0]
    eui = GetTagEUI(tag)
    tss = GetAnclTs(ancl)
    dprint('RecvTagMcast: {} <{}> flags:{:#x} ts:{}'.format(tag,eui.hex(),flags,tss.tsinfo.rawts))
    twr_status[tag] = {
        'eui'     : eui,
        'addr'    : tag,
        'start'   : time.time(),
        'expire'  : time.time() + cfg.twr_expr,
        'times'   : [None,None,None,None,None,None],
    }
    twr_status[tag]['times'][0] = 0
    twr_status[tag]['times'][1] = tss.tsinfo.rawts
    msg = struct.pack('<B', 0x08)
    tsock.sendto(msg,rem)


def RecvTagMesg(tsock):
    (data,ancl,flags,rem) = tsock.recvmsg(4096, 1024, 0)
    (flags,T1a,T1b,T1c,T1d,T1e,T2a,T2b,T2c,T2d,T2e) = struct.unpack('<B5B5B', data[0:12])
    T1 = (T1e<<32) | (T1d<<24) | (T1c<<16) | (T1b<<8) | (T1a)
    T2 = (T2e<<32) | (T2d<<24) | (T2c<<16) | (T2b<<8) | (T2a)
    tag = rem[0].partition('%')[0]
    tss = GetAnclTs(ancl)
    dprint('RecvTagMesg: {} flags:{:#x} T1:{} T2:{})'.format(tag,flags,T1,T2))
    if tag in twr_status:
        twr_status[tag]['times'][3] = T1
        twr_status[tag]['times'][4] = T2
        twr_status[tag]['times'][5] = tss.tsinfo.rawts
        eui = twr_status[tag]['eui'].hex()
        dis = TWR(twr_status[tag]['times'])
        uTrackReportTag(eui,dis)


def GetTxTime(tsock):
    (data,ancl,_,_) = tsock.recvmsg(4096, 1024, socket.MSG_ERRQUEUE)
    eui = GetRawEUI(data[5:13])
    for tag in twr_status:
        if twr_status[tag]['eui'] == eui:
            tss = GetAnclTs(ancl)
            twr_status[tag]['times'][2] = tss.tsinfo.rawts
            dprint('GetTxTime: {} <{}> ts:{}'.format(tag,eui.hex(),tss.tsinfo.rawts))
            return


def SocketLoop():

    usock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    usock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    usock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    usock.bind(cfg.utrack_bind)
    usock.listen()
    
    while True:

        msock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        msock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        ireq = struct.pack('I', cfg.if_index)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_IF, ireq)
        
        addr = socket.inet_pton(socket.AF_INET6, cfg.mcast_addr)
        mreq = struct.pack('16sI', addr, cfg.if_index)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_JOIN_GROUP, mreq)
        
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 0)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)
        
        msock.setsockopt(socket.SOL_SOCKET, socket.SO_TIMESTAMPING,
                         socket.SOF_TIMESTAMPING_RX_HARDWARE |
                         socket.SOF_TIMESTAMPING_TX_HARDWARE |
                         socket.SOF_TIMESTAMPING_RAW_HARDWARE)
        
        msock.bind(cfg.mcast_bind)
        
        tsock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_TIMESTAMPING,
                         socket.SOF_TIMESTAMPING_RX_HARDWARE |
                         socket.SOF_TIMESTAMPING_TX_HARDWARE |
                         socket.SOF_TIMESTAMPING_RAW_HARDWARE)
        
        tsock.bind(cfg.twr_bind)

        pobj = select.poll()
        pobj.register(usock, select.POLLIN)
        pobj.register(msock, select.POLLIN)
        pobj.register(tsock, select.POLLIN)

        fail = 0
        while fail < 30:
            fail += 1
            PurgeTWRs()
            for (fd,flags) in pobj.poll(100):
                try:
                    if fd == msock.fileno():
                        if flags & select.POLLIN:
                            RecvTagMcast(msock,tsock)
                    if fd == tsock.fileno():
                        if flags & select.POLLIN:
                            RecvTagMesg(tsock)
                        if flags & select.POLLERR:
                            GetTxTime(tsock)
                    if fd == usock.fileno():
                        if flags & select.POLLIN:
                            uTrackAddClient(usock)
                    fail = 0
                except (ValueError,KeyError,IndexError,RuntimeError) as err:
                    eprint('ERROR: {}'.format(err))

        PurgeTWRs(all=True)
        
        msock.close()
        tsock.close()



def main():

    global DEBUG
    
    parser = argparse.ArgumentParser(description="uTrack Connector daemon")

    parser.add_argument('-D', '--debug', action='count', default=0)
    parser.add_argument('-p', '--port', type=int, default=cfg.utrack_port)
    parser.add_argument('--mcast-port', type=int, default=cfg.mcast_port)
    parser.add_argument('--twr-port', type=int, default=cfg.twr_port)
    
    args = parser.parse_args()

    DEBUG = args.debug
    
    cfg.if_addr  = netifaces.ifaddresses(cfg.if_name)
    cfg.if_index = socket.if_nametoindex(cfg.if_name)
    
    cfg.twr_port    = args.twr_port
    cfg.twr_bind    = ('', cfg.twr_port, 0, cfg.if_index)
    
    cfg.mcast_port  = args.mcast_port
    cfg.mcast_bind  = ('', cfg.mcast_port, 0, cfg.if_index)

    cfg.utrack_port = args.port
    cfg.utrack_bind = ('', cfg.utrack_port, 0, 0)

    dprint('uTrack Connector daemon starting...')

    try:
        
        SetDWAttr('channel', cfg.dw1000_channel)
        SetDWAttr('pcode', cfg.dw1000_pcode)
        SetDWAttr('prf', cfg.dw1000_prf)
        SetDWAttr('rate', cfg.dw1000_rate)
        SetDWAttr('txpsr', cfg.dw1000_txpsr)
        SetDWAttr('smart_power', 0)
        SetDWAttr('tx_power', cfg.dw1000_power)

        SocketLoop()

    except KeyboardInterrupt:
        dprint('Exiting...')
    

if __name__ == "__main__":
    
    for name,value in (
            ('SO_TIMESTAMPING', 37),
            ('SO_SELECT_ERR_QUEUE', 45),
            ('SOF_TIMESTAMPING_TX_HARDWARE',  (1<<0)),
            ('SOF_TIMESTAMPING_TX_SOFTWARE',  (1<<1)),
            ('SOF_TIMESTAMPING_RX_HARDWARE',  (1<<2)),
            ('SOF_TIMESTAMPING_RX_SOFTWARE',  (1<<3)),
            ('SOF_TIMESTAMPING_SOFTWARE',     (1<<4)),
            ('SOF_TIMESTAMPING_SYS_HARDWARE', (1<<5)),
            ('SOF_TIMESTAMPING_RAW_HARDWARE', (1<<6))):
        if not hasattr(socket, name):
            setattr(socket, name, value)
            
    main()


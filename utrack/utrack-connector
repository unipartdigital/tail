#!/usr/bin/python3
#
# uTrack Station connector daemon
#

import sys
import time
import socket
import select
import ctypes
import struct
import array
import argparse
import ipaddress
import netifaces
import json

from ctypes import *


class Config():

    dw1000_channel  = 7
    dw1000_pcode    = 20
    dw1000_rate     = 850
    dw1000_txpsr    = 1024
    dw1000_power    = 0x91919191
    dw1000_sysfs    = '/sys/devices/platform/soc/3f204000.spi/spi_master/spi0/spi0.0/dw1000/'

    if_name         = 'lowpan0'
    if_addr         = None
    if_index        = 0

    mcast_addr      = 'ff12::52'
    mcast_port      = 0xf0b0
    mcast_bind      = None
    
    twr_port        = 0xf0b1
    twr_bind        = None
    twr_expr        = 1.0

    utrack_port     = 6299
    utrack_bind     = None

cfg = Config()

twr_status = {}
utrack_sockets = []

DEBUG = 0

C_AIR = 299705000

DW1000_CLOCK_GHZ = 63.8976


for name,value in (
        ('SO_TIMESTAMPING', 37),
        ('SO_SELECT_ERR_QUEUE', 45),
	('SOF_TIMESTAMPING_TX_HARDWARE',  (1<<0)),
  	('SOF_TIMESTAMPING_TX_SOFTWARE',  (1<<1)),
        ('SOF_TIMESTAMPING_RX_HARDWARE',  (1<<2)),
        ('SOF_TIMESTAMPING_RX_SOFTWARE',  (1<<3)),
        ('SOF_TIMESTAMPING_SOFTWARE',     (1<<4)),
        ('SOF_TIMESTAMPING_SYS_HARDWARE', (1<<5)),
        ('SOF_TIMESTAMPING_RAW_HARDWARE', (1<<6)),
        ('SOF_TIMESTAMPING_OPT_ID',       (1<<7)),
        ('SOF_TIMESTAMPING_TX_SCHED',     (1<<8)),
        ('SOF_TIMESTAMPING_TX_ACK',       (1<<9)),
        ('SOF_TIMESTAMPING_OPT_CMSG',     (1<<10)),
        ('SOF_TIMESTAMPING_OPT_TSONLY',   (1<<11)),
        ('SOF_TIMESTAMPING_OPT_STATS',    (1<<12)),
        ('SOF_TIMESTAMPING_OPT_PKTINFO',  (1<<13)),
        ('SOF_TIMESTAMPING_OPT_TX_SWHW',  (1<<14))):
    if not hasattr(socket, name):
        setattr(socket, name, value)


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def dprint(*args, **kwargs):
    if DEBUG > 0:
        print(*args, file=sys.stderr, **kwargs)



class Timespec(Structure):

    _fields_ = [("tv_sec", c_long),
                ("tv_nsec", c_long)]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)

    def __int__(self):
        return ((self.tv_sec * 1000000000 + self.tv_nsec) << 32)

    def __str__(self):
        return '%#x' % int(self)

    def __bool__(self):
        return bool(self.tv_sec or self.tv_nsec)


class Timehires(Structure):

    _fields_ = [
        ("tv_nsec", c_uint64),
        ("tv_frac", c_uint32),
        ("__res", c_uint32) ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)

    def __int__(self):
        return ((self.tv_nsec << 32) | self.tv_frac)

    def __str__(self):
        return '%#x' % int(self)

    def __bool__(self):
        return bool(self.tv_nsec or self.tv_frac)


class TimestampInfo(Structure):

    _fields_ = [
        ("rawts", c_uint64),
        ("lqi", c_uint16),
        ("snr", c_uint16),
        ("fpr", c_uint16),
        ("noise", c_uint16),
        ("rxpacc", c_uint16),
        ("fp_index", c_uint16),
        ("fp_ampl1", c_uint16),
        ("fp_ampl2", c_uint16),
        ("fp_ampl3", c_uint16),
        ("cir_pwr", c_uint32),
        ("fp_pwr", c_uint32),
        ("ttcko", c_uint32),
        ("ttcki", c_uint32),
        ("temp", c_uint16),
        ("volt", c_uint16),
    ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)


class Timestamp(Structure):

    _fields_ = [
        ("sw", Timespec),
        ("legacy", Timespec),
        ("hw", Timespec),
        ("hires", Timehires),
        ("tsinfo", TimestampInfo),
    ]

    def __iter__(self):
        return ((x[0], getattr(self,x[0])) for x in self._fields_)


def uTrackReportTag(eui,dist):
    print('* <{}> {:.3f}m'.format(eui,dist))
    msg = {
        'EUI'  : eui,
        'Dist' : int(dist*1000),
    }
    data = json.dumps(msg).encode() + b'\x1f'
    for s in list(utrack_sockets):
        try:
            s.send(data)
        except:
            utrack_sockets.remove(s)
            dprint('Removed client {}'.format(s))


def PurgeTWRs():
    now = time.time()
    for tag in list(twr_status.keys()):
        if twr_status[tag]['expire'] < now:
            dprint('Purging old TWR for <{}>'.format(tag))
            del twr_status[tag]


def TWR(times):
    dprint('TWR with {}'.format(times))
    (T1,T2,T3,T4,T5,T6) = times[0:6]
    T41 = T4 - T1
    T32 = T3 - T2
    T54 = T5 - T4
    T63 = T6 - T3
    T51 = T5 - T1
    T62 = T6 - T2
    Tof = (T41*T63 - T32*T54) / (T51+T62)
    Dof = Tof / DW1000_CLOCK_GHZ
    Lof = Dof * C_AIR * 1E-9
    if Lof<-1.0 or Lof>30.0:
        raise ValueError('Distance out-of-bounds')
    return Lof


def SetDWAttr(attr, data):
    fd = open(cfg.dw1000_sysfs + attr, 'w')
    fd.write(str(data))
    fd.close()

def GetDWAttr(attr):
    fd = open(cfg.dw1000_sysfs + attr, 'r')
    val = fd.read().rstrip()
    fd.close()
    return val

def GetTagEUI(addr):
    ip = ipaddress.ip_address(addr)
    if ip.is_link_local:
        tag = bytearray(ip.packed[8:])
        tag[0] ^= 0x02
        return tag
    else:
        return None

def GetRawEUI(data):
    eui = bytearray(data)
    eui[0],eui[7] = eui[7],eui[0]
    eui[1],eui[6] = eui[6],eui[1]
    eui[2],eui[5] = eui[5],eui[2]
    eui[3],eui[4] = eui[4],eui[3]
    return bytes(eui)

def GetAnclTs(ancl):
    tss = Timestamp()
    for cmsg_level, cmsg_type, cmsg_data in ancl:
        if (cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SO_TIMESTAMPING):
            raw = cmsg_data.ljust(sizeof(Timestamp), b'\0')
            tss = Timestamp.from_buffer_copy(raw)
    return tss


def RecvMcast(msock,tsock):
    (data,ancl,_,rem) = msock.recvmsg(4096, 1024, 0)
    (flags,) = struct.unpack('B', data[0:1])
    tag = rem[0].partition('%')[0]
    eui = GetTagEUI(tag)
    tss = GetAnclTs(ancl)
    twr_status[tag] = {
        'eui'     : eui,
        'addr'    : tag,
        'start'   : time.time(),
        'expire'  : time.time() + cfg.twr_expr,
        'times'   : [None,None,None,None,None,None],
    }
    twr_status[tag]['times'][0] = 0
    twr_status[tag]['times'][1] = tss.tsinfo.rawts
    msg = struct.pack('<B', 0x08)
    dst = (rem[0],rem[1],rem[2],rem[3])
    tsock.sendto(msg,dst)
    dprint('RecvMcast: {} {} 0x{:02x} {}'.format(tag,eui.hex(),flags,tss.tsinfo.rawts))


def RecvTag(tsock):
    (data,ancl,flags,rem) = tsock.recvmsg(4096, 1024, 0)
    (flags,T1a,T1b,T1c,T1d,T1e,T2a,T2b,T2c,T2d,T2e) = struct.unpack('<B5B5B', data[0:12])
    T1 = (T1e<<32) | (T1d<<24) | (T1c<<16) | (T1b<<8) | (T1a)
    T2 = (T2e<<32) | (T2d<<24) | (T2c<<16) | (T2b<<8) | (T2a)
    tag = rem[0].partition('%')[0]
    tss = GetAnclTs(ancl)
    dprint('RecvTag(<{}>,{},{},{})'.format(tag,flags,T1,T2))
    if tag in twr_status:
        twr_status[tag]['times'][3] = T1
        twr_status[tag]['times'][4] = T2
        twr_status[tag]['times'][5] = tss.tsinfo.rawts
        try:
            dis = TWR(twr_status[tag]['times'])
        except Exception as err:
            eprint('TWR failed: {}'.format(err))
        else:
            eui = twr_status[tag]['eui'].hex()
            uTrackReportTag(eui,dis)
        del twr_status[tag]


def GetTxTime(tsock):
    (data,ancl,_,_) = tsock.recvmsg(4096, 1024, socket.MSG_ERRQUEUE)
    eui = GetRawEUI(data[5:13])
    for tag in twr_status:
        if twr_status[tag]['eui'] == eui:
            tss = GetAnclTs(ancl)
            twr_status[tag]['times'][2] = tss.tsinfo.rawts
            dprint('GetTxTime({},{},{})'.format(tag,eui.hex(),tss.tsinfo.rawts))
            return


def SocketLoop():

    usock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    usock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    usock.bind(cfg.utrack_bind)
    usock.listen()
    
    while True:

        msock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        msock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        ireq = struct.pack('I', cfg.if_index)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_IF, ireq)
        
        addr = socket.inet_pton(socket.AF_INET6, cfg.mcast_addr)
        mreq = struct.pack('16sI', addr, cfg.if_index)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_JOIN_GROUP, mreq)
        
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 0)
        msock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)
        
        msock.setsockopt(socket.SOL_SOCKET, socket.SO_TIMESTAMPING,
                         socket.SOF_TIMESTAMPING_RX_HARDWARE |
                         socket.SOF_TIMESTAMPING_TX_HARDWARE |
                         socket.SOF_TIMESTAMPING_RAW_HARDWARE)
        
        msock.bind(cfg.mcast_bind)
        
        tsock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        tsock.setsockopt(socket.SOL_SOCKET, socket.SO_TIMESTAMPING,
                         socket.SOF_TIMESTAMPING_RX_HARDWARE |
                         socket.SOF_TIMESTAMPING_TX_HARDWARE |
                         socket.SOF_TIMESTAMPING_RAW_HARDWARE)
        
        tsock.bind(cfg.twr_bind)

        pobj = select.poll()
        pobj.register(usock, select.POLLIN)
        pobj.register(msock, select.POLLIN)
        pobj.register(tsock, select.POLLIN)

        fail = 0
        while fail < 30:
            fail += 1
            PurgeTWRs()
            fds = pobj.poll(100)
            for (fd,flags) in fds:
                if fd == usock.fileno():
                    if flags & select.POLLIN:
                        (csock,caddr) = usock.accept()
                        utrack_sockets.append(csock)
                        dprint('New client: {}'.format(caddr))
                if fd == msock.fileno():
                    if flags & select.POLLIN:
                        RecvMcast(msock,tsock)
                        fail = 0
                if fd == tsock.fileno():
                    if flags & select.POLLIN:
                        RecvTag(tsock)
                        fail = 0
                    if flags & select.POLLERR:
                        GetTxTime(tsock)
        
        msock.close()
        tsock.close()



def main():
    
    global cfg
    
    parser = argparse.ArgumentParser(description="uTrack Connector daemon")

    parser.add_argument('-D', '--debug', action='count', default=0, help='Enable debug prints')
    parser.add_argument('-i', '--interface', type=str, default=cfg.if_name)
    parser.add_argument('-p', '--port', type=int, default=cfg.utrack_port)
    parser.add_argument('--mcast-port', type=int, default=cfg.mcast_port)
    parser.add_argument('--twr-port', type=int, default=cfg.twr_port)
    
    args = parser.parse_args()

    DEBUG = args.debug
    
    cfg.if_name   = args.interface
    cfg.if_addr   = netifaces.ifaddresses(args.interface)
    cfg.if_index  = socket.if_nametoindex(args.interface)
    
    cfg.twr_port    = args.twr_port
    cfg.twr_bind    = ('', cfg.twr_port, 0, cfg.if_index)
    
    cfg.mcast_port  = args.mcast_port
    cfg.mcast_bind  = ('', cfg.mcast_port, 0, cfg.if_index)

    cfg.utrack_port = args.port
    cfg.utrack_bind = ('', cfg.utrack_port, 0, 0)
    
    SetDWAttr('channel', cfg.dw1000_channel)
    SetDWAttr('pcode', cfg.dw1000_pcode)
    SetDWAttr('rate', cfg.dw1000_rate)
    SetDWAttr('txpsr', cfg.dw1000_txpsr)
    SetDWAttr('smart_power', 0)
    SetDWAttr('tx_power', cfg.dw1000_power)

    SocketLoop()
    

if __name__ == "__main__":
    main()

